{"title":"Springboot 实现 ES-SQL 的流程","uid":"30d936a7afc35294893d61738d3f7081","slug":"SpringBootES","date":"2023-03-11T09:47:46.000Z","updated":"2023-03-12T08:42:09.366Z","comments":true,"path":"api/articles/SpringBootES.json","keywords":null,"cover":"https://cdn.pixabay.com/photo/2013/10/09/02/27/lake-192990_960_720.jpg","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>记录一个最近半年犯了两次的低级编码错误，校验某个字符串信息为枚举类的某实例时，写成了：枚举类的实例.equals(字符串) ，结果总是 false  ，打印信息貌似正确，实际执行结果总是不达预期，仔细看看代码才发现问题。本文记录本周开发工作中遇到的几个小问题，Bug 是无法完全消除的，只能尽量减少。</p>\n<h2 id=\"ES-连接及时关闭\"><a href=\"#ES-连接及时关闭\" class=\"headerlink\" title=\"ES 连接及时关闭\"></a>ES 连接及时关闭</h2><p>查看某进程的端口占用时，看到好多正连接着的 ES 连接对象，普通的 Java Web 应用，没有后台任务，怎么会保持这么多连接呢？</p>\n<p><strong>问题分析</strong>：代码有缺陷，有些请求使用 ES 进行数据查询完成后，没有关闭 ES 连接对象。ES 连接不关闭，有什么问题呢？</p>\n<p>Linux 的每个连接都会创建一个文件句柄，毫无疑问，Socket 连接用完后不关闭，会导致端口资源泄漏。</p>\n<h2 id=\"jackson-序列化异常\"><a href=\"#jackson-序列化异常\" class=\"headerlink\" title=\"jackson 序列化异常\"></a>jackson 序列化异常</h2><p>在将 ElasticSearch 的 Response 对象序列化时碰到一个异常信息：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Caused by: com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class org.elasticsearch.common.text.Text and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: org.elasticsearch.action.search.SearchResponse[&quot;hits&quot;]-&gt;org.elasticsearch.search.SearchHits[&quot;hits&quot;]-&gt;org.elasticsearch.search.SearchHit[0]-&gt;org.elasticsearch.search.SearchHit[&quot;shard&quot;]-&gt;org.elasticsearch.search.SearchShardTarget[&quot;nodeIdText&quot;])</code></pre>\n<p>有两种解决办法：</p>\n<ul>\n<li>定义一个配置类，设置 jackson 的序列化配置属性。</li>\n<li>通过 SpringBoot 的全局配置 <code>spring.jackson.serialization.FAIL_ON_EMPTY_BEANS</code> 设置为 <code>false</code> ，该配置默认为 <code>true</code>，这个方式更方便。</li>\n</ul>\n<h2 id=\"ElasticSearch-执行-SQL-的-Java-实现\"><a href=\"#ElasticSearch-执行-SQL-的-Java-实现\" class=\"headerlink\" title=\"ElasticSearch 执行 SQL 的 Java 实现\"></a>ElasticSearch 执行 SQL 的 Java 实现</h2><p>回到文章标题说的问题，ElasticSearch 6 以后的版本支持 SQL 语句检索了，如何用 Java 代码实现 ES SQL 检索呢？</p>\n<p><strong>第一 Part，基础知识。</strong><br>先搞明白需求及相关的技术支持，主要如下：</p>\n<ul>\n<li>ElasticSearch-SQL 功能，区分 GitHub 上的一个插件和 ElasticSearch 自身的支持能力。ES 6 以后内置了X-Pack 组件，提供了  Elasticsearch SQL 能力，就是说不用安装插件就可以使用 ES SQL 能力了。而网上很多都是介绍 ElasticSearch SQL 插件安装的，却不曾想 ES 已经内置了。</li>\n<li>ES 6 与 ES 8 的 Rest API 的语法不一样，8 以上的版本语句是 <code>/_xpack/_sql?format=</code> ，但是旧版本是 <code>/_xpack/sql?format=</code> ，版本依赖问题有时候挺坑的。网上大量的资料，估计都是来自官网，全都是 <code>/_xpack/_sql?format=，</code>结果我测试用的环境是 ES6 的，一直报错。</li>\n</ul>\n<p><strong>第二 Part， Java 实现 ES-SQL 操作的几种方法：</strong></p>\n<ul>\n<li>Rest API 请求 <code>/_xpack/sql?format=</code>。</li>\n<li>*JDBC-ES ，这个功能是收费的。</li>\n</ul>\n<p><strong>第三 Part，使用 <code>elasticsearch-rest-high-level-client</code> 包的 <code>RestAPI</code> 客户端工具可以实现 ES-SQL 的操作。基本思路是构建一个 RestClient 对象，请求路径为   <code>/_xpack/_sql?format=json </code>这个用 txt 的时候，总是得不到结果，用 json 就没问题。</strong></p>\n<p>重要源代码如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; ES 连接信息构造\nRestClientBuilder restClientBuilder  &#x3D; null;\nif (hasPwd) &#123;\n\tfinal CredentialsProvider credentialsProvider &#x3D; new BasicCredentialsProvider();\n\t\n\t&#x2F;** 设置 ES 认证信息 *&#x2F;\n    credentialsProvider.setCredentials(AuthScope.ANY,new UsernamePasswordCredentials(userName, password));\n\trestClientBuilder &#x3D; RestClient.builder(https)\n                    .setHttpClientConfigCallback(httpAsyncClientBuilder -&gt; httpAsyncClientBuilder.setDefaultCredentialsProvider(credentialsProvider));\n&#125; else &#123;\n  \trestClientBuilder &#x3D; RestClient.builder(https)\n&#125;\n\n&#x2F;&#x2F; xpack-sql 请求构造\nString searchIndex &#x3D; &quot;&#x2F;_xpack&#x2F;sql?format&#x3D;json&quot;;\nRequest request &#x3D; new Request(&quot;POST&quot;, searchIndex);\nrequest.setJsonEntity(queryJsonString);\n\nRestClient restClient &#x3D; restClientBuilder.build();\ntry &#123;\n    Response response &#x3D; restClient.performRequest(request);\n    String body &#x3D; EntityUtils.toString(response.getEntity());\n    &#x2F;&#x2F; TODO 处理 ES 响应结果\n&#125; catch (IOException e) &#123;\n&#125;</code></pre>\n\n<h2 id=\"ToDesk-服务占据高-CPU\"><a href=\"#ToDesk-服务占据高-CPU\" class=\"headerlink\" title=\"ToDesk 服务占据高 CPU\"></a>ToDesk 服务占据高 CPU</h2><p>电脑一直占据大量的 CPU，top 看是 ToDesk 进程，执行下面的操作好了：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">sudo launchctl unload &#x2F;Library&#x2F;LaunchDaemons&#x2F;com.youqu.todesk.service.plist</code></pre>\n<p>我碰到的问题，绝对不是个例，百度是个好东西，面向百度编程也没什么不好啊！</p>\n","text":"背景记录一个最近半年犯了两次的低级编码错误，校验某个字符串信息为枚举类的某实例时，写成了：枚举类的实例.equals(字符串) ，结果总是 false ，打印信息貌似正确，实际执行结果总是不达预期，仔细看看代码才发现问题。本文记录本周开发工作中遇到的几个小问题，Bug 是无法完全...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Springboot","slug":"Springboot","count":1,"path":"api/tags/Springboot.json"},{"name":"elasticsearch","slug":"elasticsearch","count":3,"path":"api/tags/elasticsearch.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">背景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ES-%E8%BF%9E%E6%8E%A5%E5%8F%8A%E6%97%B6%E5%85%B3%E9%97%AD\"><span class=\"toc-text\">ES 连接及时关闭</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#jackson-%E5%BA%8F%E5%88%97%E5%8C%96%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">jackson 序列化异常</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ElasticSearch-%E6%89%A7%E8%A1%8C-SQL-%E7%9A%84-Java-%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">ElasticSearch 执行 SQL 的 Java 实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ToDesk-%E6%9C%8D%E5%8A%A1%E5%8D%A0%E6%8D%AE%E9%AB%98-CPU\"><span class=\"toc-text\">ToDesk 服务占据高 CPU</span></a></li></ol>","author":{"name":"Sh1mwww","slug":"blog-author","avatar":"https://img.onl/qZjVAP","link":"/","description":"及时行乐","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Goroutine基础","uid":"bee84e518ec4344cb23b6f3015f64773","slug":"Goroutine","date":"2023-03-12T07:01:19.000Z","updated":"2023-03-12T08:41:53.876Z","comments":true,"path":"api/articles/Goroutine.json","keywords":null,"cover":"https://cdn.pixabay.com/photo/2017/05/09/03/46/alberta-2297204_960_720.jpg","text":"这篇文章将关注 Go 语言基础部分。我们将讨论关于性能方面的一些知识，并通过创建一些简单的 goroutine 来扩展我们的应用程序。 我们还会关注一些 Go 语言的底层执行逻辑以及 Go 语言与其他语言的不同之处。 Go 语言的并发继续讨论之前，我们必须理解并发与并行的概念。G...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"golang","slug":"golang","count":2,"path":"api/tags/golang.json"}],"author":{"name":"Sh1mwww","slug":"blog-author","avatar":"https://img.onl/qZjVAP","link":"/","description":"及时行乐","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Git Flow 工作原理","uid":"4783a03c76b99864e7fb550cfa766073","slug":"gitflow intro","date":"2023-03-11T08:13:35.000Z","updated":"2023-03-12T08:38:47.351Z","comments":true,"path":"api/articles/gitflow intro.json","keywords":null,"cover":"https://img.onl/jzJBv7","text":"一、 Git Flow 工作模型的原理无规矩不成方圆，但是规矩太多了，则感觉到束缚。我们一个人工作的时候喜欢无拘无束，想怎么干就怎么干，没有人评判，没有人检验。时间久了就会盲目自大，以为增删改查熟悉业务就能够搞定一些。但是当项目逐渐扩大，原来的灵活逐渐变成了混乱，原来的快速迭代因...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"gitflow","slug":"gitflow","count":1,"path":"api/tags/gitflow.json"}],"author":{"name":"Sh1mwww","slug":"blog-author","avatar":"https://img.onl/qZjVAP","link":"/","description":"及时行乐","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}