{"title":"Goroutine基础","uid":"bee84e518ec4344cb23b6f3015f64773","slug":"Goroutine","date":"2023-03-12T07:01:19.000Z","updated":"2023-03-12T08:41:53.876Z","comments":true,"path":"api/articles/Goroutine.json","keywords":null,"cover":"https://cdn.pixabay.com/photo/2017/05/09/03/46/alberta-2297204_960_720.jpg","content":"<p>这篇文章将关注 Go 语言基础部分。我们将讨论关于性能方面的一些知识，并通过创建一些简单的 goroutine 来扩展我们的应用程序。</p>\n<p>我们还会关注一些 Go 语言的底层执行逻辑以及 Go 语言与其他语言的不同之处。</p>\n<h2 id=\"Go-语言的并发\"><a href=\"#Go-语言的并发\" class=\"headerlink\" title=\"Go 语言的并发\"></a>Go 语言的并发</h2><p>继续讨论之前，我们必须理解并发与并行的概念。Golang 可以实现并发和并行。</p>\n<p>我们一起来看下并发与并行的区别。</p>\n<p><strong>理解并发</strong><br><img src=\"https://img.onl/Z88suU\" ><br>应用程序可能会通过处理多个进程来完成预期的功能。我们来假设一个简单的电子商务网站，经评估有下列需要并发执行的任务：</p>\n<ul>\n<li>在网页的顶部显示最新的交易和产品信息；</li>\n<li>显示网站当前的在线用户数量；</li>\n<li>当用户选择商品之后更新购物车详情；</li>\n<li>为“目标交易额”倒计时；</li>\n</ul>\n<p>该网站需要同时运行所有这些任务，以使用户与网站保持关联，并使网站对用户有吸引力并吸引更多业务。</p>\n<p>因此，为了满足业务需要，一个简单的应用程序或者网站都可能包含一组后台运行的任务。</p>\n<p>上图所示的两个示例中，有多个任务同时执行，但是它们之间仍然有区别。让我们进一步研究以便能更了解。</p>\n<h2 id=\"理解并发与并行执行\"><a href=\"#理解并发与并行执行\" class=\"headerlink\" title=\"理解并发与并行执行\"></a>理解并发与并行执行</h2><img src=\"https://img.onl/bWNwz4\" >\n\n<h2 id=\"处理并发应用\"><a href=\"#处理并发应用\" class=\"headerlink\" title=\"处理并发应用\"></a>处理并发应用</h2><p>假设这样一种场景，我们有一台单核机器，需要完成多个任务，但有个限制，在任何时刻，单核机器上只能运行一个任务。</p>\n<p>在并发模型中，任务之间存在上下文切换。该程序正在处理多个任务，但由于我们只有单核，因此任务无法一起执行。</p>\n<p>任务之间的上下文切换很快，以至于我们感觉任务是同时运行的。</p>\n<p>在执行过程中没有并行执行的因素，因为是一个单核系统，多进程不能并行执行。</p>\n<p>如上图所示，Concurrency (Without Parallelism) 有两个任务需要并发执行。在任何时候，只有一个任务在运行并且任务之间存在上下文切换。</p>\n<h2 id=\"应用程序加入并行\"><a href=\"#应用程序加入并行\" class=\"headerlink\" title=\"应用程序加入并行\"></a>应用程序加入并行</h2><p>使用单核的情况下，存在核数限制。如果我们给机器增加核数，就可以在不同的内核上同时执行任务。</p>\n<p>在上图中(Parallelism)，任一时刻都有两个任务在执行，这两个任务运行在不同的内核上。</p>\n<p><strong>并发是某一时间段内同时处理多个任务，并行是在某一时间点能执行多个任务。</strong></p>\n<p>使用 Go 语言可以轻松地将程序从并发扩展为并行执行。</p>\n<h2 id=\"使用协程\"><a href=\"#使用协程\" class=\"headerlink\" title=\"使用协程\"></a>使用协程</h2><p>使用 Go 语言实现并发和并行，我们需要了解协程(Goroutines)的概念。Go 语言的协程可以理解为线程之上的一个包装器，由 Go 运行时管理而不是操作系统。</p>\n<p>Go 运行时负责给协程分配和回收资源，协程与完成多任务的线程非常相似但又比操作系统线程消耗更少的资源。协程与线程之间并非一对一的关系。<br><img src=\"https://img.onl/MekZHv\" ></p>\n<p>我们可以将应用程序“拆解”成多个并发任务，这些任务可以由不同的 goroutine 完成，通过这种方式即可实现了 Go 语言并发。</p>\n<p><strong>协程的优点：</strong></p>\n<ul>\n<li>更轻量级；</li>\n<li>易扩展；</li>\n<li>虚拟线程；</li>\n<li>需要更少的初始内存(2KB)；</li>\n<li>有必要的话，Go 运行时能分配更多的内存；<br>一起来看下一个简单的例子：<pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport (\n    &quot;fmt&quot;\n    &quot;time&quot;\n)\n\nfunc main() &#123;\n  start :&#x3D; time.Now()\n  func() &#123;\n    for i:&#x3D;0; i &lt; 3; i++ &#123;\n      fmt.Println(i)\n    &#125;\n  &#125;()\n\n  func() &#123;\n    for i:&#x3D;0; i &lt; 3; i++ &#123;\n      fmt.Println(i)\n    &#125;\n  &#125;()\n\n  elapsedTime :&#x3D; time.Since(start)\n\n  fmt.Println(&quot;Total Time For Execution: &quot; + elapsedTime.String())\n\n  time.Sleep(time.Second)\n&#125;</code></pre>\n上面的代码按顺序依次在 main 函数里面执行了两个独立函数。</li>\n</ul>\n<p>代码没有使用协程，程序在同一个线程中执行完成。程序没有任何的并发性，执行结果如下：<br><img src=\"https://img.onl/mZH1xu\" ><br>代码按顺序执行，从主函数开始，先执行第一个函数，再执行第二个函数，最后从主函数正常退出。</p>\n<h2 id=\"引入协程\"><a href=\"#引入协程\" class=\"headerlink\" title=\"引入协程\"></a>引入协程</h2><p>上面的场景例子中没有使用任何的协程。我们可以在执行函数之前使用 go 关键字开启协程。</p>\n<p>依旧是上面的例子，我们一起来看看使用 go 关键字开启协程之后会是什么样的：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport (\n    &quot;fmt&quot;\n    &quot;time&quot;\n)\n\nfunc main() &#123;\n  start :&#x3D; time.Now()\n  go func() &#123;\n    for i:&#x3D;0; i &lt; 3; i++ &#123;\n      fmt.Println(i)\n    &#125;\n  &#125;()\n\n  go func() &#123;\n    for i:&#x3D;0; i &lt; 3; i++ &#123;\n      fmt.Println(i)\n    &#125;\n  &#125;()\n\n  elapsedTime :&#x3D; time.Since(start)\n\n  fmt.Println(&quot;Total Time For Execution: &quot; + elapsedTime.String())\n\n  time.Sleep(time.Second)\n&#125;</code></pre>\n<p>执行上面的代码输出：<br><img src=\"https://img.onl/K7JDLW\" ></p>\n<p>上面的代码，使用 go 关键字分别开启了两个协程并执行各自的函数，包括主协程，总共有 3 个协程。</p>\n<h2 id=\"理解与顺序执行的不同\"><a href=\"#理解与顺序执行的不同\" class=\"headerlink\" title=\"理解与顺序执行的不同\"></a>理解与顺序执行的不同</h2><p>上面的代码，我们使用 go 关键字开启协程，函数会在协程中完成执行，而不是在主协程中执行，这样增加了并发并提高了程序性能。</p>\n<h2 id=\"增加并行性\"><a href=\"#增加并行性\" class=\"headerlink\" title=\"增加并行性\"></a>增加并行性</h2><img src=\"https://img.onl/HzX82U\" >\n\n<p>Go 语言里，可以通过下面这行简单的代码设置程序运行的内核数目(PS:从 Go 1.5开始，Go 的 GOMAXPROCS 默认值已经设置为 CPU 的核数)。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">runtime.GOMAXPROCS(4)</code></pre>\n<p>这可以指定程序在多核机器上运行，上面一行代码指定程序可以使用四个内核来执行。</p>\n<p>一旦创建了协程，便可以在不同的内核中执行，从而实现并行并加快程序执行速度。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package main\n\nimport (\n    &quot;fmt&quot;\n    &quot;time&quot;\n    &quot;runtime&quot;\n)\n\nfunc main() &#123;\n  runtime.GOMAXPROCS(4)\n  start :&#x3D; time.Now()\n  go func() &#123;\n    for i:&#x3D;0; i &lt; 3; i++ &#123;\n      fmt.Println(i)\n    &#125;\n  &#125;()\n\n  go func() &#123;\n    for i:&#x3D;0; i &lt; 3; i++ &#123;\n      fmt.Println(i)\n    &#125;\n  &#125;()\n\n  elapsedTime :&#x3D; time.Since(start)\n\n  fmt.Println(&quot;Total Time For Execution: &quot; + elapsedTime.String())\n\n  time.Sleep(time.Second)\n&#125;</code></pre>\n<p>上面的代码输出如下：<br><img src=\"https://img.onl/yeSAdM\" ><br>使用 Go 语言可以轻松实现并发和并行。只需在函数之前添加 go 关键字就可以提高程序执行速度。</p>\n","text":"这篇文章将关注 Go 语言基础部分。我们将讨论关于性能方面的一些知识，并通过创建一些简单的 goroutine 来扩展我们的应用程序。 我们还会关注一些 Go 语言的底层执行逻辑以及 Go 语言与其他语言的不同之处。 Go 语言的并发继续讨论之前，我们必须理解并发与并行的概念。G...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"golang","slug":"golang","count":2,"path":"api/tags/golang.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Go-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B9%B6%E5%8F%91\"><span class=\"toc-text\">Go 语言的并发</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">理解并发与并行执行</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">处理并发应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8A%A0%E5%85%A5%E5%B9%B6%E8%A1%8C\"><span class=\"toc-text\">应用程序加入并行</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B\"><span class=\"toc-text\">使用协程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E5%85%A5%E5%8D%8F%E7%A8%8B\"><span class=\"toc-text\">引入协程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%90%86%E8%A7%A3%E4%B8%8E%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%9A%84%E4%B8%8D%E5%90%8C\"><span class=\"toc-text\">理解与顺序执行的不同</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A2%9E%E5%8A%A0%E5%B9%B6%E8%A1%8C%E6%80%A7\"><span class=\"toc-text\">增加并行性</span></a></li></ol>","author":{"name":"Sh1mwww","slug":"blog-author","avatar":"https://img.onl/qZjVAP","link":"/","description":"及时行乐","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"理解 ES 查询机制","uid":"5af57275e38843538bce4be83af3cccf","slug":"es-search","date":"2023-03-12T07:19:46.000Z","updated":"2023-03-12T08:41:33.842Z","comments":true,"path":"api/articles/es-search.json","keywords":null,"cover":"https://cdn.pixabay.com/photo/2015/12/01/20/28/road-1072821_960_720.jpg","text":"为什么需要使用 ES 进行搜索ES除了拥有索引上的优势，最重要的还是数据的结构，这都是ES为什么效率高，会使用它的原因。 1，结构化数据 VS 非结构化数据 结构化数据： 也称作行数据，关系型数据库进行存储和管理,是由二维表结构来逻辑表达和实现(可以使用行、列来表现)的数据，严格...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"elasticsearch","slug":"elasticsearch","count":3,"path":"api/tags/elasticsearch.json"}],"author":{"name":"Sh1mwww","slug":"blog-author","avatar":"https://img.onl/qZjVAP","link":"/","description":"及时行乐","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Springboot 实现 ES-SQL 的流程","uid":"30d936a7afc35294893d61738d3f7081","slug":"SpringBootES","date":"2023-03-11T09:47:46.000Z","updated":"2023-03-12T08:42:09.366Z","comments":true,"path":"api/articles/SpringBootES.json","keywords":null,"cover":"https://cdn.pixabay.com/photo/2013/10/09/02/27/lake-192990_960_720.jpg","text":"背景记录一个最近半年犯了两次的低级编码错误，校验某个字符串信息为枚举类的某实例时，写成了：枚举类的实例.equals(字符串) ，结果总是 false ，打印信息貌似正确，实际执行结果总是不达预期，仔细看看代码才发现问题。本文记录本周开发工作中遇到的几个小问题，Bug 是无法完全...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Springboot","slug":"Springboot","count":1,"path":"api/tags/Springboot.json"},{"name":"elasticsearch","slug":"elasticsearch","count":3,"path":"api/tags/elasticsearch.json"}],"author":{"name":"Sh1mwww","slug":"blog-author","avatar":"https://img.onl/qZjVAP","link":"/","description":"及时行乐","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}