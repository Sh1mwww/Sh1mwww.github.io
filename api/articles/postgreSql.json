{"title":"PostgreSQL数据的存储基础知识","uid":"ad53f22647fa1ab58dafd47d2fbb69ce","slug":"postgreSql","date":"2023-03-28T08:23:16.000Z","updated":"2023-03-28T08:27:10.342Z","comments":true,"path":"api/articles/postgreSql.json","keywords":null,"cover":[],"content":"<h1 id=\"PostgerSQL对象标识符\"><a href=\"#PostgerSQL对象标识符\" class=\"headerlink\" title=\"PostgerSQL对象标识符\"></a>PostgerSQL对象标识符</h1><p>对象标识符是PostSQL很重要的一个特征，需要熟练掌握。</p>\n<h2 id=\"OID\"><a href=\"#OID\" class=\"headerlink\" title=\"OID\"></a>OID</h2><p>OID 是 PostgreSQL 内部用于标识数据库对象(数据库，表**，<strong>视图</strong>，**存储过程等等)的标识符，用4个字节的无符号整数表示。它是PostgreSQL大部分系统表的主键。</p>\n<p>类型<code>oid</code>表示一个对象标识符。 也有多个<code>oid</code>的别名类型：<code>regproc</code>,<code>regprocedure</code>, <code>regoper</code>, <code>regoperator</code>,<code>regclass</code>, <code>regtype</code>, <code>regrole</code>,<code>regnamespace</code>, <code>regconfig</code>, 和<code>regdictionary</code>。</p>\n<p><img src=\"https://img.onl/G0vFdN\"></p>\n<p>OID的别名类型除了特定的输入和输出例程之外没有别的操作。这些例程可以接受并显示系统对象的符号名，而不是类型<code>oid</code>使用的原始数字值。别名类型使查找对象的OID值变得简单。例如，要检查与一个表<code>course</code>有关的<code>pg_attribute</code>行，你可以写：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">SELECT * FROM pg_attribute WHERE attrelid &#x3D; &#39;course&#39;::regclass;</code></pre>\n\n<p><img src=\"https://img.onl/UiE5Lz\"></p>\n<p>OID 在系统表中通常是作为隐藏列存在的，它是以整个PostgreSQL数据库实例(<strong>Database Cluster</strong>)的范围内统一分配。因为只有四个字节，因此，<strong>在大型数据库中它并不足以提供数据库范围内的唯一性，甚至在一些大型的表中也无法提供表范围内的唯一性。</strong></p>\n<p>OID 在旧版本中还可以用于标识元组，对于没有主键，重复的行，此时 OID 作为唯一 ID，则可以根据它进行删除指定行数据。我们之前创建表时，default_with_oids 默认是关闭的。在老版本中执行 create table 语句时可以指定开启 OID。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">create table foo (\n    id integer,\n    content text\n) with oids;</code></pre>\n\n<p>不过从 Postgres 12 开始，删除了将 OID 用作表上的可选系统列。将无法再使用：</p>\n<ul>\n<li><code>CREATE TABLE … WITH OIDS</code> 命令</li>\n<li><code>default_with_oids (boolean)</code> 相容性设定</li>\n</ul>\n<p>数据类型<code>OID</code>保留在Postgres 12中。您可以显式创建类型的列<code>OID</code>。</p>\n<h2 id=\"XID\"><a href=\"#XID\" class=\"headerlink\" title=\"XID\"></a>XID</h2><p>事务ID：</p>\n<ul>\n<li>由32位组成，这就有可能造成事务ID回卷的问题，具体参考<a href=\"https://link.juejin.cn/?target=https://www.postgresql.org/docs/current/static/routine-vacuuming.html%23vacuum-for-wraparound\">文档</a></li>\n<li>顺序产生，依次递增</li>\n<li>没有数据变更，如INSERT、UPDATE、DELETE等操作，在当前会话中，事务ID不会改变</li>\n</ul>\n<p>数据库系统中使用的数据类型为 <code>xmin</code> 和 <code>xmax</code>。</p>\n<ul>\n<li>xmin 存储的是产生这个元组的事务ID，可能是insert或者update语句</li>\n<li>xmax 存储的是删除或者锁定这个元组的XID</li>\n</ul>\n<p>简单示例如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">select id, xmin, xmax from course;</code></pre>\n\n<p><img src=\"https://img.onl/yDlzCR\"></p>\n<p>当 PostgreSQL的XID 到达40亿，会造成溢出，从而新的XID 为0。而按照 PostgreSQL的MVCC 机制实现，之前的事务就可以看到这个新事务创建的元组，而新事务不能看到之前事务创建的元组，这违反了事务的可见性。具体参考<a href=\"https://link.juejin.cn/?target=https://www.postgresql.org/docs/current/static/routine-vacuuming.html%23vacuum-for-wraparound\">文档</a></p>\n<h2 id=\"CID\"><a href=\"#CID\" class=\"headerlink\" title=\"CID\"></a>CID</h2><p>CID 名为命令标识符，PG 每个表都包含一些系统字段，关于 CID 用到的数据类型为 cmax 和 cmin。</p>\n<ul>\n<li>cmin:插入该元组的命令在插入事务中的命令标识（从0开始累加）</li>\n<li>cmax:删除该元组的命令在插入事务中的命令标识（从0开始累加）</li>\n</ul>\n<p>cmin和cmax用于判断同一个事务内的其他命令导致的行版本变更是否可见。如果一个事务内的所有命令严格顺序执行，那么每个命令总能看到之前该事务内的所有变更，不需要使用命令标识。</p>\n<p>简单示例如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">select id, xmin, xmax,cmin,cmax from course;</code></pre>\n\n<p><img src=\"https://img.onl/jpGUwh\"></p>\n<h2 id=\"TID\"><a href=\"#TID\" class=\"headerlink\" title=\"TID\"></a>TID</h2><p>TID 称为元组标识符（行标识符），一个元组ID是一个（块号，块内元组索引）对，它标识了行在它的表中的物理位置。</p>\n<p>简单示例如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">select ctid,id, xmin, xmax,cmin,cmax from course;</code></pre>\n\n<p><img src=\"https://img.onl/YRetg2\"></p>\n<p>了解完上述四大标识符后，我们接着来学习 PostgreSQL 中数据到底是怎么存储的。</p>\n<p>​</p>\n<h1 id=\"PostgreSQL数据存储\"><a href=\"#PostgreSQL数据存储\" class=\"headerlink\" title=\"PostgreSQL数据存储\"></a>PostgreSQL数据存储</h1><p>关于数据存储，我们都知道数据是存在数据库中的某个数据表中，每条数据记录对应数据表中的某一行，所以我们从上至下来查看各层次结构的数据存储。</p>\n<h2 id=\"PGDATA目录结构\"><a href=\"#PGDATA目录结构\" class=\"headerlink\" title=\"PGDATA目录结构\"></a>PGDATA目录结构</h2><p>PGDATA 是 PostgreSQL 用来存放所有数据的地方。</p>\n<p>关于 PGDATA 的设置，可以先执行下述命令。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">postgres&#x3D;# show data_directory;\n       data_directory        \n-----------------------------\n &#x2F;Library&#x2F;PostgreSQL&#x2F;12&#x2F;data\n(1 row)</code></pre>\n\n<p>接下来我们来看一下 <code>PGDATA</code> 文件夹中有哪些文件，首先打开命令行窗口，然后进入到上述目录。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">MacBook-Pro 12 % cd &#x2F;Library&#x2F;PostgreSQL&#x2F;12&#x2F;data\ncd: permission denied: &#x2F;Library&#x2F;PostgreSQL&#x2F;12&#x2F;data</code></pre>\n\n<p>如果遇到上述问题，则执行如下命令，尝试使用 sudo 模拟 postgresql 用户登录：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">MacBook-Pro 12 % sudo -u postgres -i\n\nThe default interactive shell is now zsh.\nTo update your account to use zsh, please run &#96;chsh -s &#x2F;bin&#x2F;zsh&#96;.\nFor more details, please visit https:&#x2F;&#x2F;support.apple.com&#x2F;kb&#x2F;HT208050.</code></pre>\n\n<p>接着执行如下命令：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">tree -FL 1 &#x2F;Library&#x2F;PostgreSQL&#x2F;12&#x2F;data\n\n&#x2F;Library&#x2F;PostgreSQL&#x2F;12&#x2F;data\n├── PG_VERSION\n├── base&#x2F;\n├── current_logfiles\n├── global&#x2F;\n├── log&#x2F;\n├── pg_commit_ts&#x2F;\n├── pg_dynshmem&#x2F;\n├── pg_hba.conf\n├── pg_ident.conf\n├── pg_logical&#x2F;\n├── pg_multixact&#x2F;\n├── pg_notify&#x2F;\n├── pg_replslot&#x2F;\n├── pg_serial&#x2F;\n├── pg_snapshots&#x2F;\n├── pg_stat&#x2F;\n├── pg_stat_tmp&#x2F;\n├── pg_subtrans&#x2F;\n├── pg_tblspc&#x2F;\n├── pg_twophase&#x2F;\n├── pg_wal&#x2F;\n├── pg_xact&#x2F;\n├── postgresql.auto.conf\n├── postgresql.conf\n├── postmaster.opts\n└── postmaster.pid</code></pre>\n\n<p>介绍几个常见的文件夹：</p>\n<ul>\n<li><code>base/</code>：存储 database 数据（除了指定其他表空间的），子目录的名字为该数据库在 <code>pg_database</code>里的 OID。</li>\n<li><code>postgresql.conf</code>：postgresql 配置文件</li>\n</ul>\n<h2 id=\"database数据存储\"><a href=\"#database数据存储\" class=\"headerlink\" title=\"database数据存储\"></a>database数据存储</h2><p>上文提到在 base&#x2F; 目录下存放着每个 database 数据，其中文件名我们叫做 dboid。</p>\n<p>由于 OID 是系统表的隐藏列，因此查看系统表中数据库对象的OID时，必须在SELECT语句中显式指定。我们进入 postgres 命令行窗口，执行下述命令：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">postgres&#x3D;# select oid,datname from pg_database;\n  oid  |  datname  \n-------+-----------\n 13635 | postgres\n     1 | template1\n 13634 | template0\n 16395 | mydb\n 16396 | dvdrental\n 16399 | testdb\n(6 rows)\nselect oid,relname from pg_class order by oid;</code></pre>\n\n<p>我们可以在 PGDATA 文件夹下的 base 目录下看到 oid</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">MacBook-Pro:base postgres$ ls &#x2F;Library&#x2F;PostgreSQL&#x2F;12&#x2F;data&#x2F;base\n1\t13634\t13635\t16395\t16396\t16399</code></pre>\n\n<p>从上述内容可知 postgres 数据库相关的数据存储在 <code>PGDATA/base/13635</code> 目录里面。</p>\n<h2 id=\"table数据存储\"><a href=\"#table数据存储\" class=\"headerlink\" title=\"table数据存储\"></a>table数据存储</h2><p>上文我们定位到数据库的存储位置，接着我们来定位数据表的位置。</p>\n<p>每一张表的数据（大部分）又是放在 <code>$PGDATA/base/&#123;dboid&#125;/&#123;relfilenode&#125;</code> 这个文件里面，<code>relfilenode</code>一般情况下和和<code>tboid</code>一致，但有些情况下也会变化，如<code>TRUNCATE</code>、<code>REINDEX</code>、<code>CLUSTER</code>以及某些形式的<code>ALTER TABLE</code>。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">CREATE TABLE public.cities (\n\tcity varchar(80) NOT NULL,\n\t&quot;location&quot; point NULL,\n\tCONSTRAINT cities_pkey PRIMARY KEY (city)\n);\n\npostgres&#x3D;# select oid,relfilenode from pg_class where relname &#x3D; &#39;cities&#39;;\n  oid  | relfilenode \n-------+-------------\n 16475 |       16475\n(1 row)\n\ninsert into cities values(&#39;北京&#39;,null);\ninsert into cities values(&#39;上海&#39;,null);\n\ntruncate cities ;\n\npostgres&#x3D;# select oid,relfilenode from pg_class where relname &#x3D; &#39;cities&#39;;\n  oid  | relfilenode \n-------+-------------\n 16475 |       16480\n(1 row)\n\nSELECT * FROM pg_attribute WHERE attrelid &#x3D; &#39;course&#39;::regclass;</code></pre>\n\n<p>除了上述 SQL 语句，我们还可以通过系统函数 pg_relation_filepath 来查看指定表的文件存储位置。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">postgres&#x3D;# select pg_relation_filepath(&#39;cities&#39;);\n pg_relation_filepath \n----------------------\n base&#x2F;13635&#x2F;16480\n(1 row)</code></pre>\n\n<p>当查看 <code>PGDATA/base/13635/</code> 目录时，会发现 16480 的文件夹，除此之外还会发现有些文件命名为 <code>relfilenode_fsm</code>、<code>relfilenode_vm</code>、<code>relfilenode_init</code>， 关于 16480 通常会有三种文件：16480、16480_fsm、16480_vm，分别是该数据库对应表的数据或索引文件、其对应的空闲空间映射文件、其对应的可见性映射文件。</p>\n<p>如果数据文件过大，那么会怎么命名呢？</p>\n<p>在表或者索引超过1GB之后，它就被划分成1GB大小的段。 第一个段的文件名和文件节点相同，随后的段被命名为 <code>filenode.1</code>、<code>filenode.2</code>等等。这样的安排避免了在某些有文件大小限制的平台上的问题。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">postgres&#x3D;# create table bigdata(id int,name varchar(64));\n\n\npostgres&#x3D;# insert into bigdata select generate_series(1,20000000) as key, md5(random()::text);\n\n\npostgres&#x3D;# select pg_relation_filepath(&#39;bigdata&#39;);\n pg_relation_filepath \n----------------------\n base&#x2F;13635&#x2F;16486\n(1 row)\n\n#切换命令行界面\nMacBook-Pro:base postgres$ ls 13635 |grep 16486\n16486\n16486.1\n16486_fsm  </code></pre>\n\n<h2 id=\"元组数据存储\"><a href=\"#元组数据存储\" class=\"headerlink\" title=\"元组数据存储\"></a>元组数据存储</h2><p>上文我们提到 table 存储时，每个数据文件（堆文件、索引文件）可存储 1G 的容量，每个文件内部又是有若干个固定的页组成。页的默认大小为8192字节(8KB)。单个表文件中的这些页(Page)从0开始进行顺序编号，这些编号也称为“块编号(<code>Block Numbers</code>)”。如果第一页空间已经被数据填满，则 postgres 会立刻重新在文件末尾(即已填满页的后面)添加一个新的空白页，用于继续存储数据，一直持续这个过程，直到当前表文件大小达到 1GB位置。若文件达到1GB，则重新创建一个新的表文件，然后重复上面的这个过程。</p>\n<p>每个页的内部又由一个页文件头(<code>Page Header</code>)、若干行指针(<code>Line Pointer</code>)、若干个元组数据(Heaple Tuple)组成。因为每个文件默认大小为 1GB，页大小为 8kb，则每个文件大概有 131072 个页。</p>\n<p>首先来看一下页面结构。</p>\n<p><img src=\"https://img.onl/JiDut2\"></p>\n<p>其中：</p>\n<ul>\n<li><p><code>page header</code>: 24 字节，存储 page 的基本信息，包括 pd_lsn、pd_checksum、pd_special…<br> pd_lsn: 存储最近改变该页面的xlog。 pd_checksum：存储页面校验和。 pd_lower，pd_upper：pd_lower指向行指针（line pointer）的尾部，pd_upper指向最后那个元组。 pd_special: 索引页面中使用，它指向特殊空间的开头。 pd_flags：用以设置位标志。 pd_pagesize_version：页面大小及页面版本号。 pd_prune_xid：可删除的旧 XID，如果没有则为零。 复制代码</p>\n</li>\n<li><p><code>line pointe</code>：行指针，4 bytes，形为 <code>(offset, length)</code> 的二元组，指向相关 tuple</p>\n</li>\n<li><p><code>heap tuple</code>: 用来存储 row 的数据，注意元组是从页面的尾部向前堆积的，元组和行指针之间的是数据页的空闲空间。</p>\n</li>\n<li><p>空白处：未申请空间，新的 line point 从其首端申请，新的 tuple 从其尾端申请</p>\n</li>\n</ul>\n<p>因此我们找 row 的数据需要知道哪一个 page，page 的哪一个 item， <code>(page_index, item_index)</code>， 通常称它为 <code>CTID(ItemPointer)</code>， 我们可以通过下面语句查看每一列的 CTID：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">select ctid,* from course;</code></pre>\n\n<p>查询结果如下所示：</p>\n<p><img src=\"https://img.onl/vwVA5\"></p>\n<p>关于元组结构以及数据变化的详解讲解，可以参考<a href=\"https://link.juejin.cn/?target=https://www.modb.pro/db/37973\">本文</a>。</p>\n<p>​</p>\n<h1 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h1><h2 id=\"schema\"><a href=\"#schema\" class=\"headerlink\" title=\"schema\"></a>schema</h2><p>PostgreSQL 除了默认的 public schema 之外，还有两个比较重的系统 schema：information_schema 与pg_catalog。</p>\n<p>通过查看 <code>pg_catalog.pg_namespace</code> 来查看当前数据库中全部的 schema。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">postgres&#x3D;# select * from pg_catalog.pg_namespace ;\n  oid  |      nspname       | nspowner |               nspacl                \n-------+--------------------+----------+-------------------------------------\n    99 | pg_toast           |       10 | \n 12314 | pg_temp_1          |       10 | \n 12315 | pg_toast_temp_1    |       10 | \n    11 | pg_catalog         |       10 | &#123;postgres&#x3D;UC&#x2F;postgres,&#x3D;U&#x2F;postgres&#125;\n  2200 | public             |       10 | &#123;postgres&#x3D;UC&#x2F;postgres,&#x3D;UC&#x2F;postgres&#125;\n 13335 | information_schema |       10 | &#123;postgres&#x3D;UC&#x2F;postgres,&#x3D;U&#x2F;postgres&#125;\n(6 rows)</code></pre>\n\n<p>我们创建的表、视图、索引等默认都在 public 下。</p>\n<p>information_schema 是方便用户查看表／视图／函数信息提供的，它大多是视图。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">select * from information_schema.&quot;tables&quot;;</code></pre>\n\n<p><img src=\"https://img.onl/q4QSt\"></p>\n<p>pg_catalog 包含系统表和所有内置数据类型、函数、操作符。pg_catalog 下有很多系统表，比如说 <strong>pg_class</strong>、<strong>pg_attribute</strong>、<strong>pg_authid</strong>等。</p>\n","feature":true,"text":"PostgerSQL对象标识符对象标识符是PostSQL很重要的一个特征，需要熟练掌握。 OIDOID 是 PostgreSQL 内部用于标识数据库对象(数据库，表**，视图，**存储过程等等)的标识符，用4个字节的无符号整数表示。它是PostgreSQL大部分系统表的主键。 类...","link":"","photos":[],"count_time":{"symbolsCount":"7.8k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"postgreSQL","slug":"postgreSQL","count":3,"path":"api/tags/postgreSQL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#PostgerSQL%E5%AF%B9%E8%B1%A1%E6%A0%87%E8%AF%86%E7%AC%A6\"><span class=\"toc-text\">PostgerSQL对象标识符</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#OID\"><span class=\"toc-text\">OID</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#XID\"><span class=\"toc-text\">XID</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CID\"><span class=\"toc-text\">CID</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TID\"><span class=\"toc-text\">TID</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#PostgreSQL%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">PostgreSQL数据存储</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PGDATA%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">PGDATA目录结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#database%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">database数据存储</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#table%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">table数据存储</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%83%E7%BB%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">元组数据存储</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%89%A9%E5%B1%95\"><span class=\"toc-text\">扩展</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#schema\"><span class=\"toc-text\">schema</span></a></li></ol></li></ol>","author":{"name":"Sh1mwww","slug":"blog-author","avatar":"https://img.onl/qZjVAP","link":"/","description":"及时行乐","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"在ES的PostgreSql中使用JSONB","uid":"537e66c74d7eb8b9f47d0409dbb02915","slug":"postgre-jsonb","date":"2023-03-28T07:07:16.000Z","updated":"2023-03-28T08:21:14.200Z","comments":true,"path":"api/articles/postgre-jsonb.json","keywords":null,"cover":"https://cdn.pixabay.com/photo/2013/10/09/02/27/lake-192990_960_720.jpg","text":"引言​ 通过本文可掌握在pg数据库中如何正确使用json字段，如何进行数据查询，在where子查询中如何使用，以及对json值进行聚合查询使用. ​ 概述JSON 代表 JavaScript Object Notation。JSON是开放的标准格式，由key-value对组成。J...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"postgreSQL","slug":"postgreSQL","count":3,"path":"api/tags/postgreSQL.json"}],"author":{"name":"Sh1mwww","slug":"blog-author","avatar":"https://img.onl/qZjVAP","link":"/","description":"及时行乐","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}