[{"id":"a67c51c6c77417a95da0e6122a3df82b","title":"springbot-es","content":"","slug":"springbot-es","date":"2023-03-12T06:13:49.000Z","categories_index":"","tags_index":"","author_index":"Sh1mwww"},{"id":"30d936a7afc35294893d61738d3f7081","title":"Springboot 实现 ES-SQL 的流程","content":"背景记录一个最近半年犯了两次的低级编码错误，校验某个字符串信息为枚举类的某实例时，写成了：枚举类的实例.equals(字符串) ，结果总是 false  ，打印信息貌似正确，实际执行结果总是不达预期，仔细看看代码才发现问题。本文记录本周开发工作中遇到的几个小问题，Bug 是无法完全消除的，只能尽量减少。\nES 连接及时关闭查看某进程的端口占用时，看到好多正连接着的 ES 连接对象，普通的 Java Web 应用，没有后台任务，怎么会保持这么多连接呢？\n问题分析：代码有缺陷，有些请求使用 ES 进行数据查询完成后，没有关闭 ES 连接对象。ES 连接不关闭，有什么问题呢？\nLinux 的每个连接都会创建一个文件句柄，毫无疑问，Socket 连接用完后不关闭，会导致端口资源泄漏。\njackson 序列化异常在将 ElasticSearch 的 Response 对象序列化时碰到一个异常信息：\nCaused by: com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class org.elasticsearch.common.text.Text and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: org.elasticsearch.action.search.SearchResponse[&quot;hits&quot;]-&gt;org.elasticsearch.search.SearchHits[&quot;hits&quot;]-&gt;org.elasticsearch.search.SearchHit[0]-&gt;org.elasticsearch.search.SearchHit[&quot;shard&quot;]-&gt;org.elasticsearch.search.SearchShardTarget[&quot;nodeIdText&quot;])\n有两种解决办法：\n\n定义一个配置类，设置 jackson 的序列化配置属性。\n通过 SpringBoot 的全局配置 spring.jackson.serialization.FAIL_ON_EMPTY_BEANS 设置为 false ，该配置默认为 true，这个方式更方便。\n\nElasticSearch 执行 SQL 的 Java 实现回到文章标题说的问题，ElasticSearch 6 以后的版本支持 SQL 语句检索了，如何用 Java 代码实现 ES SQL 检索呢？\n第一 Part，基础知识。先搞明白需求及相关的技术支持，主要如下：\n\nElasticSearch-SQL 功能，区分 GitHub 上的一个插件和 ElasticSearch 自身的支持能力。ES 6 以后内置了X-Pack 组件，提供了  Elasticsearch SQL 能力，就是说不用安装插件就可以使用 ES SQL 能力了。而网上很多都是介绍 ElasticSearch SQL 插件安装的，却不曾想 ES 已经内置了。\nES 6 与 ES 8 的 Rest API 的语法不一样，8 以上的版本语句是 /_xpack/_sql?format= ，但是旧版本是 /_xpack/sql?format= ，版本依赖问题有时候挺坑的。网上大量的资料，估计都是来自官网，全都是 /_xpack/_sql?format=，结果我测试用的环境是 ES6 的，一直报错。\n\n第二 Part， Java 实现 ES-SQL 操作的几种方法：\n\nRest API 请求 /_xpack/sql?format=。\n*JDBC-ES ，这个功能是收费的。\n\n第三 Part，使用 elasticsearch-rest-high-level-client 包的 RestAPI 客户端工具可以实现 ES-SQL 的操作。基本思路是构建一个 RestClient 对象，请求路径为   /_xpack/_sql?format=json 这个用 txt 的时候，总是得不到结果，用 json 就没问题。\n重要源代码如下：\n&#x2F;&#x2F; ES 连接信息构造\nRestClientBuilder restClientBuilder  &#x3D; null;\nif (hasPwd) &#123;\n\tfinal CredentialsProvider credentialsProvider &#x3D; new BasicCredentialsProvider();\n\t\n\t&#x2F;** 设置 ES 认证信息 *&#x2F;\n    credentialsProvider.setCredentials(AuthScope.ANY,new UsernamePasswordCredentials(userName, password));\n\trestClientBuilder &#x3D; RestClient.builder(https)\n                    .setHttpClientConfigCallback(httpAsyncClientBuilder -&gt; httpAsyncClientBuilder.setDefaultCredentialsProvider(credentialsProvider));\n&#125; else &#123;\n  \trestClientBuilder &#x3D; RestClient.builder(https)\n&#125;\n\n&#x2F;&#x2F; xpack-sql 请求构造\nString searchIndex &#x3D; &quot;&#x2F;_xpack&#x2F;sql?format&#x3D;json&quot;;\nRequest request &#x3D; new Request(&quot;POST&quot;, searchIndex);\nrequest.setJsonEntity(queryJsonString);\n\nRestClient restClient &#x3D; restClientBuilder.build();\ntry &#123;\n    Response response &#x3D; restClient.performRequest(request);\n    String body &#x3D; EntityUtils.toString(response.getEntity());\n    &#x2F;&#x2F; TODO 处理 ES 响应结果\n&#125; catch (IOException e) &#123;\n&#125;\n\nToDesk 服务占据高 CPU电脑一直占据大量的 CPU，top 看是 ToDesk 进程，执行下面的操作好了：\nsudo launchctl unload &#x2F;Library&#x2F;LaunchDaemons&#x2F;com.youqu.todesk.service.plist\n我碰到的问题，绝对不是个例，百度是个好东西，面向百度编程也没什么不好啊！\n","slug":"SpringBootES","date":"2023-03-11T09:47:46.000Z","categories_index":"","tags_index":"","author_index":"Sh1mwww"},{"id":"4783a03c76b99864e7fb550cfa766073","title":"Git Flow 工作原理","content":"一、 Git Flow 工作模型的原理无规矩不成方圆，但是规矩太多了，则感觉到束缚。我们一个人工作的时候喜欢无拘无束，想怎么干就怎么干，没有人评判，没有人检验。时间久了就会盲目自大，以为增删改查熟悉业务就能够搞定一些。但是当项目逐渐扩大，原来的灵活逐渐变成了混乱，原来的快速迭代因为过于随意的代码，而开发进度迟迟不前。掌握一种规范，便在处理类似问题的时候有章可循，也能够快速的融入一个团队。另外所谓规范，可以说是比较好的实践，按照规范来，项目也能稳健的发展。\nGit Flow 就是如何使用git 分支的一种规范，或者叫做推荐。\n根据Git Flow 的推荐，我们要将Git 的分支分为 master 、develop 、hotfix 、release、feature这五个分支。各种分支分别负责不同的功能，平时开发的时候各司其职，因此会有比较小的冲突率。那么可以用这些减少冲突的时间，少加会班，多有点自己的生活岂不快哉。一图胜千言：\n\n\nmaster 分支master 分支主要方稳定、随时可上线的版本。这个分支只能从别的分支上合并过来，一般来讲，从develop 上合并，或者从bugfix 分支上合并过来。不能直接在master 分支上进行commit文件。因为是稳定的版本，所以每次版本发布都要在这个分支上添加标签(tag)。\ndevelop 分支develop 分支是所有开发分支的母体，所有的开发分支都要从develop上切出来，开发完成之后最后都要合并到develop上。\nhotfix 分支hotfix 分支用来修复生产中的紧急bug，由于develop分支尚处于开发过程中，代码不稳定，不能直接应用于生产。所以从master分支上切出一个分支，修复完成之后合并到master分支，并且合并到develop上。\nrelease 分支release 分支可以称之为预发布的版本。当我们认为develop版本的代码已经趋于成熟，我们可以打一个release分支。在release 分支上测试完成之后，要将代码合并到master分支和develop上。master 分支是线上版本，而合并到develop版本是因为，在测试过程中，一些细节的东西可能会修改，因此这些优化的内容也应该合并到最终版本以及开发版本中。\nfeature 分支feature 分支是最经常使用的分支了。当我们收到一个新的开发功能时，应该在develop分支上切出一个feature分支。用来完成新功能的开发，开发完成之后，要合并进develop分支上。\n二、 Git Flow 工具的使用基本上各种git的客户端软件都会支持Git Flow 工作模型。sourcetree 上使用git flow 工作模型就很流畅，体验很好。但是为了全平台上通用，以及理解原理，快速上手。我们来学习下Git Flow 的命令行操作。\ngit flow 是一种git的使用规范，当然也有相应的工具集，命令行命令让我们使用。\n\n\n1、起步安装git flow\nbrew install git-flow-avh\n初始化git flow 工具库\ngit flow init\n之后都按照默认的去配置，直接按enter键继续。\n2、feature 分支操作增加feature新特性分支\ngit flow feature start your roverliang&#x2F;addlist\n示例:\nroverliang$ git flow feature start roverliang&#x2F;addlist\nSwitched to a new branch &#39;feature&#x2F;roverliang&#x2F;addlist&#39;\n\nSummary of actions:\n- A new branch &#39;feature&#x2F;roverliang&#x2F;addlist&#39; was created, based on &#39;develop&#39;\n- You are now on branch &#39;feature&#x2F;roverliang&#x2F;addlist&#39;\n\nNow, start committing on your feature. When done, use:\n\n     git flow feature finish roverliang&#x2F;addlist\n\nroverliang$ git branch\n  develop\n* feature&#x2F;roverliang&#x2F;addlist\n  master\n完成新特性这个动作执行的是下面的流程:\n\n合并 addlist 分支到 develop\n删除这个新特性分支\n切换回 develop 分支git flow feature finish roverliang&#x2F;addlist\n\n示例：\nroverliang$ git flow feature finish roverliang&#x2F;addlist\nSwitched to branch &#39;develop&#39;\nYour branch is up to date with &#39;origin&#x2F;develop&#39;.\nAlready up to date.\nDeleted branch feature&#x2F;roverliang&#x2F;addlist (was 2e1b475).\n\nSummary of actions:\n- The feature branch &#39;feature&#x2F;roverliang&#x2F;addlist&#39; was merged into &#39;develop&#39;\n- Feature branch &#39;feature&#x2F;roverliang&#x2F;addlist&#39; has been locally deleted\n- You are now on branch &#39;develop&#39;\n\nroverliang$ git branch\n* develop\n  master\nroverliang$\n获取一个发布的新特性的分支\ngit flow feature track origin MYFEATURE\n\n3、release 分支操作准备release 版本\ngit flow release start RELEASE [BASE]\n\n你可以选择提供一个 [BASE]参数，即提交记录的 sha-1 hash 值，来开启动 release 分支. 这个提交记录的 sha-1 hash 值必须是&#39;develop&#39; 分支下的。\n\n示例：\nroverliang$ git branch\n  develop\n  feature&#x2F;test\n* master\nroverliang$ git log --pretty&#x3D;oneline -3\n2e1b475f9825275aefa0892cfe5259aaac9a3483 (HEAD -&gt; master, origin&#x2F;test2, origin&#x2F;master, origin&#x2F;feature&#x2F;test, origin&#x2F;develop, feature&#x2F;test, develop) delte some content\n2d22f306d2dca363b8aaa05743be342a505aabb0        renamed:    demo.txt -&gt; test.txt\nfbf025e210952c3cdb10e219c4ee5f82b9f36327        modified:   demo.txt\nroverliang$\n\n发布release 版本\ngit flow release track RELEASE\n\n完成release 版本 相当于执行以下几个动作：\n\n归并 release 分支到 ‘master’ 分支\n用 release 分支名打 Tag\n归并 release 分支到 ‘develop’\n移除 release 分支git flow release finish RELEASE\n\n4、bugfix 分支操作紧急修复的需求：\n\n紧急修复来自这样的需求：生产环境的版本处于一个不预期状态，需要立即修正。\n有可能是需要修正 master 分支上某个 TAG 标记的生产版本。\n\n开始紧急修复，开启hotfix 分支\ngit flow hotfix start VERSION [BASENAME]\nVERSION 参数标记着修正版本。你可以从 [BASENAME]开始，[BASENAME]为finish release时填写的版本号\n\n完成紧急修复:当完成紧急修复分支，代码归并回 develop 和 master 分支。相应地，master 分支打上修正版本的 TAG。\ngit flow hotfix finish VERSION","slug":"gitflow intro","date":"2023-03-11T08:13:35.000Z","categories_index":"","tags_index":"","author_index":"Sh1mwww"},{"id":"90bb244b78e2bf4cc75c96413958b4eb","title":"ElasticSearch数据库简单介绍","content":"elasticsearch简介ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。\nelasticSearch的使用场景1、为用户提供按关键字查询的全文搜索功能。2、实现企业海量数据的处理分析的解决方案。大数据领域的重要一份子，如著名的ELK框架(ElasticSearch,Logstash,Kibana)。\n与其他数据存储进行比较\n\nelasticsearch的特点\n天然分片，天然集群  es 把数据分成多个shard，下图中的P0-P2，多个shard可以组成一份完整的数据，这些shard可以分布在集群中的各个机器节点中。随着数据的不断增加，集群可以增加多个分片，把多个分片放到多个机子上，已达到负载均衡，横向扩展。在实际运算过程中，每个查询任务提交到某一个节点，该节点必须负责将数据进行整理汇聚，再返回给客户端，也就是一个简单的节点上进行Map计算，在一个固定的节点上进行Reduces得到最终结果向客户端返回。\n\n天然索引  ES 所有数据都是默认进行索引的，这点和mysql正好相反，mysql是默认不加索引，要加索引必须特别说明，ES只有不加索引才需要说明。而ES使用的是倒排索引和Mysql的B+Tree索引不同。\n\n\n传统关系性数据库\n弊端：\n\n对于传统的关系性数据库对于关键词的查询，只能逐字逐行的匹配，性能非常差。\n*匹配方式不合理，比如搜索“小密手机” ，如果用like进行匹配， 根本匹配不到。但是考虑使用者的用户体验的话，除了完全匹配的记录，还应该显示一部分近似匹配的记录，至少应该匹配到“手机”。倒排索引是怎么处理的全文搜索引擎目前主流的索引技术就是倒排索引的方式。传统的保存数据的方式都是记录→单词而倒排索引的保存数据的方式是单词→记录\n\n索引结构对比可以看到 lucene 为倒排索引(Term Dictionary)部分又增加一层Term Index结构，用于快速定位，而这Term Index是缓存在内存中的，但mysql的B+tree不在内存中，所以整体来看ES速度更快，但同时也更消耗资源（内存、磁盘）。\nlucene与elasticsearch的关系咱们之前讲的处理分词，构建倒排索引，等等，都是这个叫lucene的做的。那么能不能说这个lucene就是搜索引擎呢？\n还不能。lucene只是一个提供全文搜索功能类库的核心工具包，而真正使用它还需要一个完善的服务框架搭建起来的应用。\n好比lucene是类似于发动机，而搜索引擎软件（ES,Solr）就是汽车。\n目前市面上流行的搜索引擎软件，主流的就两款，elasticsearch和solr,这两款都是基于lucene的搭建的，可以独立部署启动的搜索引擎服务软件。由于内核相同，所以两者除了服务器安装、部署、管理、集群以外，对于数据的操作，修改、添加、保存、查询等等都十分类似。就好像都是支持sql语言的两种数据库软件。只要学会其中一个另一个很容易上手。\n从实际企业使用情况来看，elasticSearch的市场份额逐步在取代solr，国内百度、京东、新浪都是基于elasticSearch实现的搜索功能。国外就更多了 像维基百科、GitHub、Stack Overflow等等也都是基于ES的。\n","slug":"elk","date":"2023-03-05T07:57:17.000Z","categories_index":"","tags_index":"","author_index":"Sh1mwww"},{"id":"d4105a7b8a6b6b0d8864aefbdb368e9a","title":"mylover","content":"tags:    mylover兴趣广泛，喜欢篮球足球hiphop\n","slug":"mylover","date":"2022-04-15T07:42:17.000Z","categories_index":"","tags_index":"","author_index":"Sh1mwww"},{"id":"bccecdef4d85db8990deae967274cbf8","title":"myfirstblog","content":"简单的简介这是我的第一个blog，一个简单的hexo框架构成的网站\nSh1mwww本人很懒。不会定期更新使用","slug":"myfirstblog","date":"2022-04-15T07:41:44.855Z","categories_index":"","tags_index":"","author_index":"Sh1mwww"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-04-04T08:45:44.257Z","categories_index":"","tags_index":"","author_index":"Sh1mwww"}]